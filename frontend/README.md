# План разработки Frontend-приложения "Mini-Holders"

Этот документ содержит пошаговый план и чек-лист для создания клиентской части приложения на Next.js.

## 1. Технологический стек

*   **Фреймворк**: Next.js (App Router)
*   **Язык**: TypeScript
*   **UI-библиотека**: Mantine
*   **Взаимодействие с блокчейном**: TON Connect (`@tonconnect/ui-react`, `@tonconnect/sdk`)
*   **Real-time обновления**: WebSockets (нативная поддержка в браузерах или `socket.io-client`)
*   **HTTP-запросы к бэкенду**: `axios` или нативный `fetch`

## 2. Архитектура и принцип работы

Фронтенд является "тонким" клиентом. Его основная задача — отображать пользовательский интерфейс, реагировать на действия пользователя и на сообщения от бэкенда. Он **не содержит критической бизнес-логики**. Вся логика верификации и принятия решений находится на бэкенде.

**Ключевые принципы:**
1.  **Оркестрация**: Фронтенд выступает как дирижер между тремя сторонами: пользователем, его кошельком и нашим бэкендом.
2.  **Отображение состояния**: Фронтенд получает данные от бэкенда (статус счета, сумму) и отображает их. Он не производит вычислений, а только показывает то, что сказал ему бэкенд.
3.  **Инициация действий**: Пользователь нажимает кнопки на фронтенде, который затем запрашивает у кошелька подписи или транзакции, а у бэкенда — создание счетов или проверку данных.

---

## 3. Чек-лист разработки

### ☐ Этап 1: Настройка проекта Next.js
-   [ ] Инициализировать проект: `npx create-next-app@latest --typescript --tailwind --eslint`.
-   [ ] Установить зависимости:
    -   UI: `@mantine/core @mantine/hooks`
    -   TON: `@tonconnect/ui-react`
    -   HTTP: `axios`
-   [ ] Настроить **Mantine**: сконфигурировать `MantineProvider` в корневом `layout.tsx`.
-   [ ] Создать базовую структуру страниц (например, главная, страница оплаты).

### ☐ Этап 2: Интеграция TON Connect и Аутентификация
-   [ ] Обернуть приложение в `TonConnectUIProvider` в файле `providers.tsx` (или прямо в `layout.tsx`).
-   [ ] Указать в провайдере `manifestUrl`, который будет указывать на `tonconnect-manifest.json`, размещенный на вашем бэкенде или в папке `/public`.
-   [ ] Добавить кнопку `<TonConnectButton />` в шапку сайта для простого подключения кошелька.
-   [ ] Реализовать логику аутентификации (например, в хуке `useAuth`):
    -   [ ] После подключения кошелька (`useTonConnectUI().onStatusChange`), проверить, есть ли у нас сессия с бэкендом.
    -   [ ] Если сессии нет, запросить у бэкенда `challenge`: `POST /api/auth/challenge`.
    -   [ ] Полученный `payload` использовать для запроса `ton_proof` у кошелька. Это делается через `tonConnectUI.connector.connect()`.
    -   [ ] Отправить полученный от кошелька объект `proof` на бэкенд для верификации: `POST /api/auth/verify`.
    -   [ ] В случае успеха, сохранить токен сессии (например, в `httpOnly` cookie, который установит бэкенд).

### ☐ Этап 3: Создание и оплата счета
-   [ ] Создать страницу `[invoiceId]` для отображения конкретного счета.
-   [ ] Реализовать функцию, которая отправляет запрос на бэкенд (`POST /api/invoices`) и после создания счета перенаправляет пользователя на его страницу.
-   [ ] На странице счета отображать его статус (`pending`, `completed`) и сумму.
-   [ ] Добавить кнопку "Оплатить через кошелек". По клику на нее:
    -   [ ] Сформировать объект транзакции, используя данные от бэкенда (адрес получателя, сумма).
    -   [ ] **Важно**: В поле `payload`/`memo` транзакции добавить уникальный идентификатор счета (`invoice_${invoiceId}`).
    -   [ ] Вызвать `tonConnectUI.sendTransaction({ messages: [...], validUntil: ... })`.
    -   [ ] Показать пользователю уведомление, что транзакция отправлена на подтверждение.

### ☐ Этап 4: Real-time обновления через WebSockets
-   [ ] На странице счета (`[invoiceId]`) установить WebSocket-соединение с бэкендом.
-   [ ] Сразу после подключения отправить сообщение с `invoiceId`, чтобы бэкенд понял, на какие обновления нужно подписать этого клиента.
-   [ ] Реализовать обработчик `onmessage` для сокета:
    -   [ ] При получении сообщения (например, `{ "status": "completed" }`), обновить состояние страницы.
    -   [ ] Показать пользователю сообщение об успешной оплате, скрыть кнопку "Оплатить".
-   [ ] Корректно закрывать WebSocket-соединение при уходе со страницы (в `useEffect` cleanup function).

### ☐ Этап 5: Пользовательский опыт и обработка ошибок
-   [ ] Показывать лоадеры во время запросов к бэкенду или ожидания ответа от кошелька.
-   [ ] Обрабатывать ошибки:
    -   Пользователь отклонил транзакцию в кошельке.
    -   Ошибка сети при запросе к бэкенду.
    -   Счет истек по времени.
-   [ ] Показывать понятные уведомления (`Toast`/`Notification`) об успехе или ошибке операций. 