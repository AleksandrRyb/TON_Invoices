# План разработки Backend-сервиса "Mini-Holders"

Этот документ содержит пошаговый план и чек-лист для создания бэкенд-части приложения.

## 1. Общая архитектура и принцип работы

Система состоит из трех ключевых компонентов:

1. **Клиент (Frontend)**: Взаимодействует с пользователем и его некостодиальным кошельком (например, Tonkeeper) через протокол TON Connect.
2. **Бэкенд (Backend)**: Наш Express.js сервер. Он не имеет доступа к ключам пользователя и не инициирует транзакции. Его главные задачи — **выдавать задания** клиенту и **верифицировать** их выполнение путем прямого обращения к блокчейну.
3. **Блокчейн TON**: Единственный источник правды. Все проверки на бэкенде основываются на данных, полученных напрямую из блокчейна.

### Принцип работы: "Не доверяй, а проверяй"

- **Аутентификация**: Бэкенд генерирует случайное сообщение (`payload`), фронтенд просит кошелек его подписать (`ton_proof`), а бэкенд затем проверяет эту подпись. Это доказывает, что пользователь владеет кошельком.
- **Оплата**: Бэкенд сообщает фронтенду **что** и **куда** перевести. Фронтенд просит кошелек выполнить эту транзакцию. Бэкенд самостоятельно находит эту транзакцию в блокчейне и проверяет все ее параметры (сумма, получатель, комментарий).

---

## 2. Чек-лист разработки

### ☐ Этап 1: Настройка проекта и окружения

- [x] Инициализировать `npm` проект (`npm init`).
- [x] Установить и настроить **TypeScript** (`tsconfig.json`).
- [x] Установить основные зависимости: `express`, `cors`, `dotenv`, `pino`.
- [x] Установить dev-зависимости: `@types/node`, `@types/express`, `ts-node-dev`, `pino-pretty`.
- [x] Создать базовую структуру папок: `/src`, `/src/api`, `/src/services`, `/src/config`.
- [x] Настроить базовый Express-сервер в `src/server.ts` и `src/app.ts`.
- [x] Добавить скрипт для запуска в режиме разработки в `package.json` (например, `"dev": "ts-node-dev ... | pino-pretty"`).

### ☐ Этап 2: Настройка базы данных с Prisma

- [x] Запустить **PostgreSQL** локально (рекомендуется через Docker).
- [x] Установить Prisma: `prisma`, `@prisma/client`.
- [x] Инициализировать Prisma (`npx prisma init`).
- [x] Настроить подключение к PostgreSQL в `.env` файле.
- [x] Создать схему данных в `prisma/schema.prisma`. Необходимые модели:
  - `User` (для хранения адреса кошелька и информации о пользователе).
  - `Invoice` (счет на оплату: сумма, статус, связь с `User`).
- [x] Применить миграцию и сгенерировать Prisma Client (`npx prisma migrate dev`).

### ☑ Этап 3: Реализация потока аутентификации (`ton_proof`)

- [x] Установить криптографические зависимости: `@ton/core`, `js-sha256`, `@tonconnect/sdk`.
- [x] Реализовать `AuthService` для stateless-аутентификации по стандарту `ton_proof`.
  - [x] Генерация `challenge` без сохранения состояния на бэкенде.
  - [x] Верификация подписи `ton_proof`, включая сложную проверку структуры сообщения, для исправления ошибки "Invalid signature".
- [x] Создать роуты `POST /api/auth/challenge` и `POST /api/auth/verify`.
- [x] Роут верификации находит или создает пользователя в БД, сохраняя адрес в user-friendly формате.
- **[x] Обновить интеграционные тесты для потока аутентификации:**
  - [x] Тестовое окружение настроено для запуска Docker и применения миграций.
  - [x] Тесты для контроллера (`auth.test.ts`) переписаны с использованием моков для сервисного слоя (`authService`, `userService`).
  - [x] Написаны тесты, покрывающие:
    - [x] Успешное получение `challenge`.
    - [x] Успешную верификацию для нового и существующего пользователя.
    - [x] Ошибку при невалидной подписи.
    - [x] Ошибку при отсутствии необходимых полей в запросе.

### ☑ Этап 4: Реализация основного платежного потока

- [x] Создать роут `POST /api/invoices`:
  - [x] Проверяет, что пользователь аутентифицирован (через проверку наличия `address` в БД).
  - [x] Создает в БД запись о новом счете со статусом `pending`.
  - [x] Возвращает `invoiceId`, сумму и **статический адрес кошелька-получателя**.
- [x] Создать роут `GET /api/invoices/:id` для получения текущего статуса счета.

### ☐ Этап 5: Интеграция WebSockets для Real-Time обновлений

- [ ] Установить библиотеку `ws`.
- [ ] Настроить `WebSocket.Server` на тот же порт, что и Express-сервер.
- [ ] Реализовать логику подписки: когда клиент подключается по WebSocket, он сообщает `invoiceId`, на который хочет подписаться.
- [ ] Создать сервис, который позволит отправлять сообщения конкретным клиентам по `invoiceId`.

### ☐ Этап 6: Верификация транзакций в блокчейне

- [ ] Создать `TonApiService` для взаимодействия с публичным TON API (например, Toncenter). Установить `axios` для HTTP-запросов.
- [ ] Реализовать фоновый процесс (для начала можно `setInterval`), который:
  - [ ] Получает из БД все счета со статусом `pending`.
  - [ ] Для каждого счета делает запрос в TON API, чтобы получить последние транзакции на **кошельке-получателе**.
  - [ ] Ищет среди транзакций ту, у которой совпадает **сумма** и **комментарий/payload** (например, `invoice_123`).
- [ ] Когда транзакция найдена и верифицирована:
  - [ ] Обновить статус счета в PostgreSQL на `completed`.
  - [ ] Отправить уведомление клиенту через WebSocket.
  - [ ] Прекратить опрос для этого счета.

### ☐ Этап 7: Безопасность и подготовка к развертыванию

- [ ] Убедиться, что все секретные данные (ключи, пароли от БД) используются только через переменные окружения (`.env`).
- [ ] Добавить валидацию для всех входящих данных (например, с помощью `zod` или `joi`).
- [ ] Настроить CORS для разрешения запросов только с вашего фронтенд-домена.
- [ ] (Опционально) Создать `Dockerfile` для контейнеризации бэкенд-приложения.
