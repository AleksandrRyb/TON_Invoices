# План разработки Backend-сервиса "Mini-Holders"

Этот документ содержит пошаговый план и чек-лист для создания бэкенд-части приложения.

## 1. Общая архитектура и принцип работы

Система состоит из трех ключевых компонентов:

1. **Клиент (Frontend)**: Взаимодействует с пользователем и его некостодиальным кошельком (например, Tonkeeper) через протокол TON Connect.
2. **Бэкенд (Backend)**: Наш Express.js сервер. Он не имеет доступа к ключам пользователя и не инициирует транзакции. Его главные задачи — **выдавать задания** клиенту и **верифицировать** их выполнение путем прямого обращения к блокчейну.
3. **Блокчейн TON**: Единственный источник правды. Все проверки на бэкенде основываются на данных, полученных напрямую из блокчейна.

### Принцип работы: "Не доверяй, а проверяй"

- **Аутентификация**: Бэкенд генерирует случайное сообщение (`payload`), фронтенд просит кошелек его подписать (`ton_proof`), а бэкенд затем проверяет эту подпись. Это доказывает, что пользователь владеет кошельком.
- **Оплата**: Бэкенд сообщает фронтенду **что** и **куда** перевести. Фронтенд просит кошелек выполнить эту транзакцию. Бэкенд самостоятельно находит эту транзакцию в блокчейне и проверяет все ее параметры (сумма, получатель, комментарий).

---

## 2. Чек-лист разработки

### ☐ Этап 1: Настройка проекта и окружения

- [x] Инициализировать `npm` проект (`npm init`).
- [x] Установить и настроить **TypeScript** (`tsconfig.json`).
- [x] Установить основные зависимости: `express`, `cors`, `dotenv`, `pino`.
- [x] Установить dev-зависимости: `@types/node`, `@types/express`, `ts-node-dev`, `pino-pretty`.
- [x] Создать базовую структуру папок: `/src`, `/src/api`, `/src/services`, `/src/config`.
- [x] Настроить базовый Express-сервер в `src/server.ts` и `src/app.ts`.
- [x] Добавить скрипт для запуска в режиме разработки в `package.json` (например, `"dev": "ts-node-dev ... | pino-pretty"`).

### ☐ Этап 2: Настройка базы данных с Prisma

- [x] Запустить **PostgreSQL** локально (рекомендуется через Docker).
- [x] Установить Prisma: `prisma`, `@prisma/client`.
- [x] Инициализировать Prisma (`npx prisma init`).
- [x] Настроить подключение к PostgreSQL в `.env` файле.
- [x] Создать схему данных в `prisma/schema.prisma`. Необходимые модели:
  - `User` (для хранения адреса кошелька и информации о пользователе).
  - `Invoice` (счет на оплату: сумма, статус, связь с `User`).
- [x] Применить миграцию и сгенерировать Prisma Client (`npx prisma migrate dev`).

### ☐ Этап 3: Реализация потока аутентификации (`ton_proof`)

- [x] Установить библиотеку для криптографии: `@ton/crypto` и `ioredis`.
- [x] Добавить `Redis` в `docker-compose.yml` для хранения challenge.
- [x] Создать сервис `AuthService`, который будет генерировать challenge и сохранять его в Redis с TTL.
- [x] Создать роут `POST /api/auth/challenge` для генерации `payload` для подписи.
- [x] Обновить `AuthService` для верификации подписи:
  - [x] Он должен получать challenge из Redis.
  - [x] Проверять подпись, `payload`, домен и временную метку.
  - [x] Удалять challenge из Redis после успешной проверки.
- [x] Создать роут `POST /api/auth/verify`, который вызывает `AuthService`, находит или создает пользователя и в будущем будет выпускать JWT.
- **[x] Написать интеграционные тесты для потока аутентификации:**
  - [x] **Подготовка тестового окружения:**
    - [x] Установить dev-зависимости: `jest`, `ts-jest`, `@types/jest`, `supertest`.
    - [x] Создать файл конфигурации `jest.config.js`.
    - [x] Создать файл `docker-compose.test.yml` с отдельными сервисами PostgreSQL и Redis для тестов.
  - [x] **Создание тестового хелпера для Prisma:**
    - [x] Написать скрипт (`setupTests.ts`), который перед запуском тестов будет подключаться к тестовой БД и применять миграции (`prisma migrate deploy`).
    - [x] Настроить Jest для выполнения этого скрипта перед тестами (`globalSetup`).
  - [x] **Написание самих тестов (`auth.test.ts`):**
    - [x] Тест для `POST /api/auth/challenge`: должен возвращать статус 200 и валидный `payload`.
    - [x] Тест для `POST /api/auth/verify` с валидной подписью: должен возвращать статус 200 и `success: true`.
    - [x] Тест для `POST /api/auth/verify` с невалидной подписью: должен возвращать статус 401.
    - [x] Тест на повторное использование challenge (replay-атака): вторая попытка верификации с тем же `payload` должна провалиться.
    - [x] Тест на истекший challenge (TTL): верификация через 5+ минут должна провалиться.
  - [x] **Интеграция с `package.json`:**
    - [x] Добавить скрипт `"test": "jest"` для запуска тестов.

### ☑ Этап 4: Реализация основного платежного потока

- [x] Создать роут `POST /api/invoices`:
  - [x] Проверяет, что пользователь аутентифицирован (через проверку наличия `address` в БД).
  - [x] Создает в БД запись о новом счете со статусом `pending`.
  - [x] Возвращает `invoiceId`, сумму и **статический адрес кошелька-получателя**.
- [x] Создать роут `GET /api/invoices/:id` для получения текущего статуса счета.

### ☐ Этап 5: Интеграция WebSockets для Real-Time обновлений

- [ ] Установить библиотеку `ws`.
- [ ] Настроить `WebSocket.Server` на тот же порт, что и Express-сервер.
- [ ] Реализовать логику подписки: когда клиент подключается по WebSocket, он сообщает `invoiceId`, на который хочет подписаться.
- [ ] Создать сервис, который позволит отправлять сообщения конкретным клиентам по `invoiceId`.

### ☐ Этап 6: Верификация транзакций в блокчейне

- [ ] Создать `TonApiService` для взаимодействия с публичным TON API (например, Toncenter). Установить `axios` для HTTP-запросов.
- [ ] Реализовать фоновый процесс (для начала можно `setInterval`), который:
  - [ ] Получает из БД все счета со статусом `pending`.
  - [ ] Для каждого счета делает запрос в TON API, чтобы получить последние транзакции на **кошельке-получателе**.
  - [ ] Ищет среди транзакций ту, у которой совпадает **сумма** и **комментарий/payload** (например, `invoice_123`).
- [ ] Когда транзакция найдена и верифицирована:
  - [ ] Обновить статус счета в PostgreSQL на `completed`.
  - [ ] Отправить уведомление клиенту через WebSocket.
  - [ ] Прекратить опрос для этого счета.

### ☐ Этап 7: Безопасность и подготовка к развертыванию

- [ ] Убедиться, что все секретные данные (ключи, пароли от БД) используются только через переменные окружения (`.env`).
- [ ] Добавить валидацию для всех входящих данных (например, с помощью `zod` или `joi`).
- [ ] Настроить CORS для разрешения запросов только с вашего фронтенд-домена.
- [ ] (Опционально) Создать `Dockerfile` для контейнеризации бэкенд-приложения.
